# Technical Decisions Deep Dive - "Why THIS and Not THAT?"

> **This file prepares you for the HARDEST interview questions:**
> "Why did you use X?" → "What alternatives did you consider?" → "What's the trade-off?"
> Every decision here is from ACTUAL code in inventory-status-srv.

---

## Decision 1: ConcurrentHashMap vs HashMap

### What's In The Code
```java
Map<String, String> wmItemNbrGtinMap = new ConcurrentHashMap<>();
```

### Why ConcurrentHashMap?

| Aspect | HashMap | ConcurrentHashMap | Why We Chose |
|--------|---------|-------------------|-------------|
| Thread safety | NOT safe | Thread-safe (lock striping) | **Populated in Stage 1, read in Stage 2 & 3** |
| Performance | Faster (no locking) | Slightly slower but safe | Acceptable for our use case |
| Null keys | Allows null | Does NOT allow null | Protects against NPE |
| When to use | Single-threaded only | Multi-threaded or shared state | Our map is shared across pipeline stages |

### Interview Answer
> "I used ConcurrentHashMap because the GTIN map is populated during UberKey calls in Stage 1 via `processWithBulkValidation` which may process items in batches. The same map is then read by Stage 2 (supplier validation) and Stage 3 (EI fetch). Even though our current code is mostly sequential, ConcurrentHashMap is defensive - if someone later makes the bulk processing parallel, it won't break. Plus, ConcurrentHashMap doesn't allow null keys, which prevents subtle NPE bugs."

### If They Ask "Why not just synchronize HashMap?"
> "Synchronized HashMap locks the entire map for every operation. ConcurrentHashMap uses lock striping - it divides the map into segments and locks only the segment being modified. For read-heavy operations like ours (one write phase, multiple read phases), ConcurrentHashMap is significantly better."

### If They Ask "Isn't this premature optimization?"
> "It's defensive coding, not optimization. The performance difference is negligible for our data size. But the thread-safety guarantee and null-key prevention are worth it. I'd rather be safe by default than debug a race condition later."

---

## Decision 2: Java Records vs Regular POJOs

### What's In The Code
```java
public record DCInventoryPayload(
    List<EIDCInventoryByInventoryType> inventoryByInventoryType,
    ItemIdentifier itemIdentifier,
    NodeInfo nodeInfo
) {}
```

### Why Records Instead of @Data Class?

| Aspect | @Data (Lombok) | Record (Java 17) | Why We Chose |
|--------|----------------|-------------------|-------------|
| Mutability | Mutable (setters) | **Immutable** (no setters) | Data from EI API shouldn't change |
| Boilerplate | Needs Lombok annotation | Built into language | No dependency on Lombok |
| equals/hashCode | Generated by Lombok | Built-in, field-based | Guaranteed correct |
| Serialization | Works with Jackson | Works with Jackson + `@JsonIgnoreProperties` | Same |
| When to use | When you need mutability | When data is read-only | Our EI responses are read-only |

### Interview Answer
> "I used Java records for the EI response models because they're data carriers - we receive them from the Enterprise Inventory API and pass them through the pipeline without modification. Records guarantee immutability by design - no setter exists to accidentally modify them. They also auto-generate equals/hashCode which is important for our map lookups and deduplication."

### If They Ask "Why not records for everything?"
> "The response DTOs like `InventorySearchDistributionCenterStatusInventoryItem` use @Builder and @Data because we build them incrementally - setting fields across multiple stages. Records don't support that pattern because they're immutable. So: records for incoming data, builders for outgoing responses."

---

## Decision 3: Factory Pattern vs If-Else vs Strategy

### What's In The Code
```java
@Component
public class SiteConfigFactory {
    private final Map<String, SiteConfigProvider> factory;  // Spring injects all

    public SiteConfigProvider getConfigurations(Long siteId) {
        return factory.get(siteIdData.get(NAME));
    }
}

@Component("US")
public class USConfig implements SiteConfigProvider { ... }

@Component("CA")
public class CAConfig implements SiteConfigProvider { ... }
```

### Why Factory Pattern?

| Approach | Adding New Country | Modifying Existing | Testability | Our Choice |
|----------|-------------------|-------------------|-------------|------------|
| **If-else** | Modify existing code | Risky, touches everything | Hard to mock | No |
| **Switch** | Modify existing code | Same risk | Same issue | No |
| **Strategy** | New class | Isolated | Each strategy testable | Close, but... |
| **Factory + Spring DI** | New class + `@Component` | Isolated, zero changes to factory | Each config independently testable | **Yes** |

### Interview Answer
> "I chose the Factory pattern with Spring's Map injection. Spring auto-discovers all `@Component` classes that implement `SiteConfigProvider` and injects them as a map. The factory just does a lookup. This means adding Mexico was literally: create MXConfig class, add `@Component('MX')`, done. No changes to the factory, service, or controller. This follows the Open-Closed Principle."

### If They Ask "How is this different from Strategy pattern?"
> "It IS the Strategy pattern, implemented via Spring DI. The factory is the context that selects which strategy to use based on siteId. The key advantage over a hand-rolled Strategy is that Spring handles the registration automatically. I don't need a static map or switch statement to register new implementations."

### If They Ask "What if the config is wrong/missing?"
> "The `getOrDefault` call provides a default US configuration as fallback. And the CCM-based `SiteIdConfig` can be updated at runtime without redeployment - so fixing a site mapping doesn't require a code change."

---

## Decision 4: Always HTTP 200 vs Status-Based Responses

### What's In The Code
```java
// Controller always returns 200
return ResponseEntity.status(HttpStatus.OK)
    .headers(responseHeaders)
    .body(response);
```

### Why Always 200?

| Approach | When Partial Success | Consumer Handling | Our Choice |
|----------|---------------------|-------------------|------------|
| **200 always** | Body has success + errors | Parse body, handle per-item | **Yes** |
| **207 Multi-Status** | RFC standard for partial | More complex parsing | Considered |
| **200 for success, 400 for any error** | Treats partial success as failure | Lose the successful items! | No |
| **200 for success, 207 for partial** | Two response formats | Consumer needs two parsers | No |

### Interview Answer
> "A 100-item bulk request where 80 succeed and 20 fail is a SUCCESSFUL request - we have useful data to return. If we returned 400 or 207, the consumer's HTTP error handling might discard the 80 successful results. With 200, the consumer always parses the body. Each item has a `dataRetrievalStatus` field - 'SUCCESS' or 'ERROR' with a `reason`. The consumer can process successful items and handle errors individually."

### If They Ask "But isn't 207 the right status for partial success?"
> "207 Multi-Status is technically correct per RFC 4918, but it's from the WebDAV spec and not widely understood by API consumers. Our suppliers are external companies with varying technical sophistication. 200 with per-item status is simpler to consume - every HTTP client handles 200. We document the partial success pattern in our OpenAPI spec."

---

## Decision 5: RequestProcessor Pattern vs Inline Validation

### What's In The Code
```java
RequestProcessingResult processedResult = requestProcessor.processWithBulkValidation(
    currentResult,                    // State: valid + invalid + errors
    identifiers -> fetchGtins(...),   // Stage function
    INVALID_WM_ITEM_NBR_MESSAGE,      // Error message
    ERROR_SOURCE_UBERKEY);            // Error source tag
```

### Why A Dedicated RequestProcessor?

| Approach | Error Tracking | Reusability | Testability | Our Choice |
|----------|---------------|-------------|-------------|------------|
| **Inline in service** | Manual, error-prone | Not reusable | Hard | No |
| **RequestProcessor** | Automatic with source tags | Reusable across APIs | Mock processor in tests | **Yes** |
| **Functional pipeline** | Complex for team | Very reusable | Easy | Over-engineered for now |

### Interview Answer
> "RequestProcessor is a pipeline pattern. Each stage function receives a list of valid identifiers, processes them, and returns a map of successes. RequestProcessor automatically separates successes from failures, tags failures with an error source (UberKey, Supplier, EI), and accumulates errors. This means the service code focuses on WHAT each stage does, not the plumbing of error tracking. The same RequestProcessor is reused across the DC Inventory API and the Search Items API."

### If They Ask "Isn't this over-engineering?"
> "It paid off when we built the second API. The Search Items API uses the same RequestProcessor with different stage functions. Without it, we'd have duplicated the error accumulation logic. The refactor in PR #322 (+1,903 lines) was largely about centralizing this pattern."

---

## Decision 6: Constructor Injection vs @Autowired

### What's In The Code
```java
public InventorySearchDistributionCenterServiceImpl(
        TransactionMarkingManager transactionMarkingManager,
        HttpServiceImpl httpService,
        UberKeyReadService uberKeyReadService,
        ServiceRequestBuilder requestBuilder,
        RequestProcessor requestProcessor) {
    this.transactionMarkingManager = transactionMarkingManager;
    this.httpService = httpService;
    // ...
}
```

### Why Constructor Injection?

| Approach | Immutability | Testability | Required Dependencies | Our Choice |
|----------|-------------|-------------|----------------------|------------|
| **@Autowired fields** | Mutable | Needs reflection in tests | Silently null if missing | No |
| **@Autowired setters** | Mutable | Can set in tests | Optional by default | No |
| **Constructor injection** | **Immutable (final fields)** | Just pass in constructor | Fails at startup if missing | **Yes** |

### Interview Answer
> "Constructor injection makes dependencies explicit and immutable. If a required service is missing, the application fails at startup - not at runtime with a NullPointerException. In tests, I just pass mock objects directly to the constructor, no reflection needed. Spring recommends constructor injection since Spring 4.3 - it's the modern best practice."

---

## Decision 7: GTIN Error Reverse-Conversion

### What's In The Code
```java
private RequestProcessingResult convertGtinErrorsToWmItemNumbers(
    RequestProcessingResult supplierMappingResult,
    Map<String, String> wmItemNbrGtinMap) {
    // Build reverse map and convert errors
}
```

### Why Convert Errors Back?

```
SUPPLIER SENDS:  wmItemNbr = "12345"
STAGE 1 MAPS:   "12345" → GTIN "00012345678905"
STAGE 2 ERROR:  "GTIN 00012345678905 not mapped to supplier"

WITHOUT CONVERSION:
  Error: "00012345678905 not found" ← Supplier says "What is this number?!"

WITH CONVERSION:
  Error: "12345 not mapped to supplier" ← Supplier says "Oh, I see the issue"
```

### Interview Answer
> "This is a UX decision at the API level. Internally, we work with GTINs because that's what the supplier mapping database uses. But the consumer sent WmItemNumbers. If we return 'GTIN 00012345678905 is not authorized,' they'd have to reverse-map that themselves. By converting errors back to WmItemNumbers, the error message makes sense in the consumer's context. It's a small detail but shows we think about the API from the consumer's perspective."

### If They Ask "What about performance of the reverse map?"
> "The reverse map is built once per request from the existing wmItemNbrGtinMap. For up to 100 items, it's negligible - microseconds. The benefit of clear error messages far outweighs the cost."

---

## Decision 8: @JsonIgnoreProperties(ignoreUnknown = true) on Models

### What's In The Code
```java
@JsonIgnoreProperties(ignoreUnknown = true)
public record DCInventoryPayload(...) {}
```

### Why ignoreUnknown?

| Without | With | Our Choice |
|---------|------|------------|
| If EI API adds a new field → our deserialization BREAKS | New fields silently ignored | **With** |
| Strict contract validation | Loose coupling | Loose - we control our spec, not EI's |

### Interview Answer
> "The EI (Enterprise Inventory) API is an internal Walmart service that we consume but don't control. If they add a new field to their response, our deserialization shouldn't break. `@JsonIgnoreProperties(ignoreUnknown = true)` makes us resilient to upstream changes. We explicitly define the fields we NEED and ignore the rest."

---

## Decision 9: OpenAPI Generated Interface vs Manual Controller

### What's In The Code
```java
@RestController
public class InventorySearchDistributionCenterController
    implements InventorySearchDistributionCenterStatusApi {  // GENERATED interface
```

### Why Generated Interface?

| Approach | Spec-Implementation Sync | Compile-Time Check | Our Choice |
|----------|-------------------------|-------------------|------------|
| **Manual controller** | Can drift from spec | No | No |
| **Generated interface** | Method signatures match spec | Yes - won't compile if wrong | **Yes** |
| **Generated controller** | Full implementation generated | Too much generated code | No |

### Interview Answer
> "We generate Java interfaces from the OpenAPI spec using `openapi-generator-maven-plugin`. The controller IMPLEMENTS this interface. If the spec says the endpoint returns `InventorySearchDistributionCenterStatusResponse`, the controller must return that type - enforced at compile time. If someone changes the spec, the controller won't compile until it's updated. This is the strongest form of spec-implementation contract."

---

## Decision 10: try-with-resources for Transaction Marking

### What's In The Code
```java
try (var uberKeyTxn = transactionMarkingManager
        .getTransactionMarkingService()
        .currentTransaction()
        .addChildTransaction(SERVICE, OPERATION)) {
    uberKeyTxn.start();
    // ... stage logic
}  // auto-closed → transaction marked as complete
```

### Why try-with-resources?

| Approach | Transaction Cleanup | Exception Handling | Our Choice |
|----------|--------------------|--------------------|------------|
| **Manual start/stop** | Must remember to stop | If exception, transaction hangs | No |
| **try-finally** | Stop in finally block | Verbose, error-prone | No |
| **try-with-resources** | Auto-closed when block exits | Even on exceptions | **Yes** |

### Interview Answer
> "Transaction marking creates child spans in Dynatrace for observability. If a stage throws an exception and we forget to close the transaction, Dynatrace shows it as still running - confusing for debugging. try-with-resources guarantees the transaction is closed regardless of success or failure. It's the same reason we use it for streams and connections."

---

## Quick Reference: All Decisions Table

| # | Decision | Chose | Over | Why |
|---|----------|-------|------|-----|
| 1 | ConcurrentHashMap | Thread-safe map | HashMap | Shared across pipeline stages |
| 2 | Java Records | Immutable models | @Data POJOs | EI responses are read-only |
| 3 | Factory + Spring DI | Auto-discovery | If-else/Switch | Open-Closed, zero changes to add country |
| 4 | Always HTTP 200 | Partial success in body | 207/400 | Consumers always parse body |
| 5 | RequestProcessor | Centralized pipeline | Inline validation | Reusable, error-source tracking |
| 6 | Constructor injection | Explicit, immutable | @Autowired fields | Fails fast, testable |
| 7 | Error reverse-conversion | WmItemNbr in errors | GTIN in errors | Consumer sees their input |
| 8 | ignoreUnknown=true | Resilient to upstream | Strict deserialization | Don't control EI API |
| 9 | Generated interface | Compile-time contract | Manual controller | Spec-implementation sync |
| 10 | try-with-resources | Auto-cleanup | Manual start/stop | Exception-safe observability |

---

## The Meta-Answer (Use This in Interviews)

When they ask "Why did you choose X?", always answer with this structure:

```
1. "We considered [alternatives]..."
2. "We chose [X] because [specific reason related to our context]..."
3. "The trade-off is [downside]..."
4. "We mitigated that by [action]..."
```

**Example:**
> "We considered HashMap, synchronized HashMap, and ConcurrentHashMap. We chose ConcurrentHashMap because the GTIN map is shared across three pipeline stages and populated during bulk processing. The trade-off is slightly lower performance than HashMap, but for up to 100 items per request, the difference is negligible. The thread-safety and null-key prevention are worth it."

---

*This is what separates a "good" answer from an "excellent" answer in a hiring manager interview.*
